// Userset Rewrite Rules definitions

syntax = "proto3";

package internal.domain.policy;
option go_package = "github.com/sourcenetwork/source-zanzibar/internal/domain/policy";

// RewriteRule specifies the logical model between relations
message RewriteRule {
    oneof rewrite_rule {
        This this = 1;
        ComputedUserset computed_userset = 2;
        TupleToUserset tuple_to_userset = 3;
    }
}

// This specifies a Rule which returns all users for a given (object, relation) pair.
// The rule performs userset chasing.
message This {}

// ComputerUserset specifies a rule to dynamically create a userset for a given object.
// The created Userset may then be used to perform additional lookups.
// It's functionally similar to "This", except it does checks using a volatile relation tuple.
message ComputedUserset {
    string relation = 1;
}

// TupleToUserset is rule which is used to traverse hierarchical relations.
// For a given object `obj` it works as follows:
// 1. Fetch the direct neighbors of the (`obj`, tuplset_relation) pair
// 2. For each fetched tuple `tf`, create a computed userset of (tf.Namespace, tf.ObjId, cu_relation)
// 
// Example:
// Let tuplset_relation = "parent"
// Let cu_relation = "owner"
// Let the input object be "doc:readme"
// TupleToUserset would then:
// 1. Lookup all tuples matching (obj="doc:readme", relation="parent").
//   Assume the matching tuples are [(obj="doc:readme", relation="parent", user=(id="dir:root", relation="..."))]
// 2. For each found tuple, it would compute the userset (obj=${result_tuple_userset_obj}, relation=cu_relation)
// The result for this example would be the userset: (obj="dir:root", relation="owner")
message TupleToUserset {
    // Relation used to fetch neighbors
    string tupleset_relation = 1;

    // Namespace to which the Computed Userset relation belongs
    string cu_relation_namespace = 2;

    // Relation to use within computed usersets
    string cu_relation = 3;
}
